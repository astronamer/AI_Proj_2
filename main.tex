\documentclass{article}
\usepackage{graphicx} % Required for inserting images
\usepackage{textcomp}
\newcommand{\forceindent}{\leavevmode{\parindent=1em\indent}}


\title{AI proj 2}
\author{DANIEL TEYTEL, Long Tran}
\date{February 2023}

\begin{document}

\maketitle

\section{Introduction}
\begin{enumerate}
\item[1:]    
(Mchadia, 311, 70, 241)

(Drobeta, 387, 145, 242)

(Craiova, 425, 265, 160)

(Timisoara, 440, 111, 329)

(Pitesti, 503, 403, 100)

(Bucharest, 504, 504, 0)

\item[]
Problem 2 (10 points): Consider a state space where the start state is number 1 and each state k has two successors: numbers 2k and 2k + 1.

(a) Suppose the goal state is 11. List the order in which states will be visited for breadth-first search, depth-limited search with limit 3, and iterative deepening search.

\textit{Assume for each iteration, algorithms will pick the lowest values in the available items list}

\textbf{Bread-first Search}
Pick s(1) \verb|->| expand s(2), s(3) \\
\forceindent Pick s(2) \verb|->| expand s(4), s(5) \\
\forceindent Pick s(3) \verb|->| expand s(6), s(7) \\
\forceindent\forceindent Pick s(4) \verb|->| expand s(8), s(9) \\
\forceindent\forceindent Pick s(5) \verb|->| expand s(10), s(11) \verb|->| find target 11 \verb|->| program done.\\

\textbf{Depth-limited Search with 3}

Search is limited with max depth is 3. Suppose s(1) is depth 0.

\#1 Pick s(1) \verb|->| s(2) \verb|->| s(4) \verb|->| s(8) \\
\#1.2 Pick s(1) \verb|->| s(2) \verb|->| s(4) \verb|->| s(9) \\
\#1.3 Pick s(1) \verb|->| s(2) \verb|->| s(5) \verb|->| s(10) \\
\#1.4 Pick s(1) \verb|->| s(2) \verb|->| s(5) \verb|->| s(11) \verb|->| Find target \\
\verb|->| Program done.

\textbf{Iterative Deepening Search}

\textbf{Limit = 1}\\
s(1) \verb|->| s(2)\\
s(1) \verb|->| s(3)\\
\verb|->| Reached limit


\textbf{Limit = 2}\\
s(1) \verb|->| s(2) \verb|->| s(4)\\
s(1) \verb|->| s(2) \verb|->| s(5)\\
s(1) \verb|->| s(3) \verb|->| s(6)\\
s(1) \verb|->| s(3) \verb|->| s(7)\\
\verb|->| Reached limit

\textbf{Limit = 3}\\
\#1 Pick s(1) \verb|->| s(2) \verb|->| s(4) \verb|->| s(8) \\
\#1.2 Pick s(1) \verb|->| s(2) \verb|->| s(4) \verb|->| s(9) \\
\#1.3 Pick s(1) \verb|->| s(2) \verb|->| s(5) \verb|->| s(10) \\
\#1.4 Pick s(1) \verb|->| s(2) \verb|->| s(5) \verb|->| s(11) \verb|->| Find target \\
\verb|->| Program done.

(b) How well would bidirectional search work on this problem? List the order in which states will be visited. What is the branching factor in each direction of the bidirectional search?

\textbf{Bidirectional order:}

It is sufficient to utilize bidirectional search. On the search from target, due to the node's characteristics, the branch factor (b) on the search tree from target is 1 (each number x has a parent node, which is x/2).

Therefore, each iteration on search tree from target will reduce 1 depth level for the search tree from 1.

Therefore, the time complexity reduce from $2^n$ to $2^{n/2}$

\begin{figure}[h!]
    \centering
    \includegraphics[width=.4\linewidth]{Hw2_2b.png}
    \caption{Bidirectional order}
    \label{bidirectional}
\end{figure}

\item[]
Problem 3 (5 points): Which of the following statements are correct and which ones are wrong?

(a) Breadth-first search is a special case of uniform-cost search.

True

(b) Depth-first search is a special case of best-first tree search.

Wrong

(c) Uniform-cost search is a special case of $A\ast$ search.

True, if setting h(i) = 0 for each n.

(d) Depth-first graph search is guaranteed to return an optimal solution.

Wrong, it is bounded by max depth of the problem and may run infintely

(e) Breadth-first graph search is guaranteed to return an optimal solution.

True

(f) Uniform-cost graph search is guaranteed to return an optimal solution.

True

(g) $A\ast$ graph search is guaranteed to return an optimal solution if the heuristic is consistent.

True

(h) $A\ast$ graph search is guaranteed to expand no more nodes than depth-first graph search if the heuristic is consistent.

False, in best case, depth-first search find optimal solution in first path try.

(i) $A\ast$ graph search is guaranteed to expand no more nodes than uniform-cost graph search if the heuristic is consistent.

True

\item[]
Problem 4 (2 points): Iterative deepening is sometimes used as an alternative to breadth first search. Give one advantage
of iterative deepening over BFS, and give one disadvantage of iterative deepening as compared with BFS. Be concise and
specific

\textbf{Advantage of Iterative Deepening}\\
- Due to the utilization of recursion function, it consumes much less memory.
Suppose search tree has large branching factor (b) and current depth limit is d, the memory it uses is to memorize the current path and the b branches at d level.
\verb|->| It consumes d + b of memory space.
Meanwhile, BFS consumes $b^d$ of memory space to memorize all the states.

\verb|->| Iterative Deepening Search has much more efficient space complexity.

\textbf{Disadvantage of Iterative Deepening}
- It revisits the states many time. Each time it increases the depth limit, it would revisit the start states again.\\
- If a target is found at depth d and tree search has branch factor b, the total number of search revisits each depth i is 
\[ \Sigma_{i=0}^d (d-i+1) \ast b^i \]
\[ b^d \ast (1 - 1/b)^{-2} \]
\[ = O(b^d)\]

Comparing to BFS, Iterative Deepening has same Time Complexity but its cons is to revisiting states as a constant rate.

\end{enumerate}


\end{document}
